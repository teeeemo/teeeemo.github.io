<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Emitter 学习笔记]]></title>
      <url>/2017/10/21/learn-emitter/</url>
      <content type="html"><![CDATA[<h1 id="Emitter-学习笔记"><a href="#Emitter-学习笔记" class="headerlink" title="Emitter 学习笔记"></a>Emitter 学习笔记</h1><h2 id="学习感想"><a href="#学习感想" class="headerlink" title="学习感想"></a>学习感想</h2><p>最好的学习资料是<a href="https://nodejs.org/api/events.html" target="_blank" rel="external">官方文档</a>, 由于是英语的, 可能造成心里压力, 阅读不下去(我就是).</p>
<a id="more"></a>
<p>我个人是先从<a href="http://javascript.ruanyifeng.com/nodejs/events.html#toc8" target="_blank" rel="external">一篇 emitter 的博客</a>对 Emitter 稍有了解再去看官方文档的, 果然这个模块真是小还简单.</p>
<p>如果这篇文章有幸被你参考, 倍感荣幸!</p>
<h2 id="概要介绍"><a href="#概要介绍" class="headerlink" title="概要介绍"></a>概要介绍</h2><p><em>中文翻译</em> 不明所以, 大概是事件分发的意思.</p>
<ul>
<li>emit: 散发,发射</li>
<li>emitter: 发射器</li>
</ul>
<p>Nodejs 中很多 API 或者内部类是基于异步调用的事件机制的, 在 nodejs 中,所有能 emit 事件的类都继承自 Emitter</p>
<p>Emitter 是 events模块导出的唯一的类, 通常作为接口被其他类继承(或可以直接实例化使用,写 demo 的时候可以这么做)</p>
<p>一个继承了 Emitter 的类, 就被注册事件, 也有了响应事件调用回调函数的能力</p>
<p>当 Emitter 类的某个事件被触发了, 这个事件绑定的所有回调函数, 将会按照 <strong>绑定顺序</strong> <strong>同步</strong>执行.</p>
<h2 id="通过-demo-一步一步了解-Emitter"><a href="#通过-demo-一步一步了解-Emitter" class="headerlink" title="通过 demo 一步一步了解 Emitter"></a>通过 demo 一步一步了解 Emitter</h2><p><strong>注意: 所有的 demo 都是 ES6 的写法</strong></p>
<h3 id="demo1-API-on-绑定事件-amp-emit-触发事件"><a href="#demo1-API-on-绑定事件-amp-emit-触发事件" class="headerlink" title="demo1: API - on(绑定事件) &amp; emit(触发事件)"></a>demo1: API - on(绑定事件) &amp; emit(触发事件)</h3><p>通过 Emitter.on()方法绑定事件, 绑定的回调方法, 可以是匿名函数, 也可以是 ES6 的箭头函数</p>
<p><strong>注意: Emitter.on() 方法有个别名, 即 Emitter.addListener() 方法</strong></p>
<p><code>emitter.on(eventName, listener)</code></p>
<p>通过 Emitter.emit()方法触发事件,可以传参数的</p>
<p><code>emitter.emit(eventName[, ...args])</code></p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventEmitter = require(&#39;events&#39;);
class MyEmitter extends EventEmitter {}
const myEmitter = new MyEmitter();
myEmitter.on(&#39;event&#39;, () =&gt; {
//myEmitter.addListener(‘event&#39;, () =&gt; {
    console.log(&#39;an event occurred!&#39;);
});
myEmitter.emit(&#39;event&#39;);
</code></pre>
<p>输出结果:</p>
<pre><code class="bash">an event occurred!
</code></pre>
<h3 id="demo2-通过-emit-向事件回调方法传入参数"><a href="#demo2-通过-emit-向事件回调方法传入参数" class="headerlink" title="demo2: 通过 emit 向事件回调方法传入参数"></a>demo2: 通过 emit 向事件回调方法传入参数</h3><p>通过 on() 绑定的回调方法是可以带有参数的,这些参数通过 emit() 方法传进回调函数中</p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventEmitter = require(&#39;events&#39;);
const EventEmitter = require(&#39;events&#39;);
class MyEmitter extends EventEmitter {}
const myEmitter = new MyEmitter();
myEmitter.on(&#39;event&#39;, function(a, b) {
    console.log(a, b, this);
});
myEmitter.emit(&#39;event&#39;, &#39;a&#39;, &#39;b&#39;);
</code></pre>
<p>输出结果:</p>
<pre><code class="bash">a b MyEmitter {
  domain: null,
  _events: { event: [Function] },
  _eventsCount: 1,
  _maxListeners: undefined }
</code></pre>
<h3 id="demo3-事件回调方法的执行顺序"><a href="#demo3-事件回调方法的执行顺序" class="headerlink" title="demo3: 事件回调方法的执行顺序"></a>demo3: 事件回调方法的执行顺序</h3><p>一个事件可以绑定多个回调方法, 当这个事件被触发时, 所有的回调方法会按照它们绑定的顺序依次同步执行.</p>
<p><strong>注意: 回调事件中可以执行异步操作</strong></p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventsEmitter = require(&#39;events&#39;);
class MyEmitter extends EventsEmitter {}
let myEmitter = new MyEmitter();
const cb1 = () =&gt; setTimeout(() =&gt; {
    console.log(&#39;cb1&#39;)
}, 100);
// const cb1 = () =&gt; console.log(&#39;cb1&#39;);
const cb2 = () =&gt; console.log(&#39;cb2&#39;);
const cb3 = () =&gt; console.log(&#39;cb3&#39;);
const cb4 = () =&gt; console.log(&#39;cb4&#39;);
myEmitter.on(&#39;me&#39;,cb1);
myEmitter.on(&#39;me&#39;,cb2);
myEmitter.on(&#39;me&#39;,cb3);
myEmitter.on(&#39;me&#39;,cb4);
myEmitter.emit(&#39;me&#39;);
</code></pre>
<p>输出结果:</p>
<pre><code class="bash">cb2
cb3
cb4
cb1
</code></pre>
<h3 id="demo4-API-once-只会被调用一次的回调方法"><a href="#demo4-API-once-只会被调用一次的回调方法" class="headerlink" title="demo4: API - once(只会被调用一次的回调方法)"></a>demo4: API - once(只会被调用一次的回调方法)</h3><p>通过 on() 绑定的回调方法, 无论被 emit() 触发多少次, 都会被执行.</p>
<p>通过 once() 绑定的回调方法, 在回调方法绑定后第一次触发才会被执行.(实际上执行后该回调方法, 就在该事件的回调列表中去除了).</p>
<p><strong>注意: once() 指的是该回调方法只会被触发一次, 并非该事件只会被触发一次</strong></p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventsEmitter = require(&#39;events&#39;);
class MyEmitter extends EventsEmitter {}
let myEmitter = new MyEmitter();
const cb1 = () =&gt; console.log(&#39;cb1&#39;);
const cb2 = () =&gt; console.log(&#39;cb2&#39;);
const cb3 = () =&gt; console.log(&#39;cb3&#39;);
myEmitter.once(&#39;me&#39;,cb1);
myEmitter.once(&#39;me&#39;,cb2);
myEmitter.on(&#39;me&#39;,cb3);
// 执行两次 me 事件
myEmitter.emit(&#39;me&#39;);
myEmitter.emit(&#39;me&#39;);
</code></pre>
<p>输出结果:</p>
<pre><code class="bash">cb1
cb2
cb3
cb3
</code></pre>
<h3 id="demo5-API-prependListener-在队首添加回调方法"><a href="#demo5-API-prependListener-在队首添加回调方法" class="headerlink" title="demo5: API - prependListener(在队首添加回调方法)"></a>demo5: API - prependListener(在队首添加回调方法)</h3><p>绑定事件的方法,用法同 on().</p>
<p>然而通过 on 绑定的回调方法, 会 push 进回调方法队列, <strong>后绑定后执行</strong>.</p>
<p>通过 prependListener 绑定的回调方法, 则是会 unshift 进回调方法队列, <strong>后绑定先执行</strong>.</p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventsEmitter = require(&#39;events&#39;);
class MyEmitter extends EventsEmitter {
}
let myEmitter = new MyEmitter();
const cb1 = () =&gt; console.log(&#39;cb1&#39;);
const cb2 = () =&gt; console.log(&#39;cb2&#39;);
const cb3 = () =&gt; console.log(&#39;cb3&#39;);
const cb4 = () =&gt; console.log(&#39;cb4&#39;);
myEmitter.on(&#39;me&#39;, cb1);
myEmitter.on(&#39;me&#39;, cb2);
myEmitter.on(&#39;me&#39;, cb3);
myEmitter.prependListener(&#39;me&#39;, cb4);
myEmitter.emit(&#39;me&#39;);
</code></pre>
<p>输出结果:</p>
<pre><code class="bash">cb4
cb1
cb2
cb3
</code></pre>
<h3 id="demo6-API-prependOnceListener-队首绑定一次性回调"><a href="#demo6-API-prependOnceListener-队首绑定一次性回调" class="headerlink" title="demo6: API - prependOnceListener(队首绑定一次性回调)"></a>demo6: API - prependOnceListener(队首绑定一次性回调)</h3><p>不赘述, 参考 once() &amp; prependListener()<br>没有什么特殊的</p>
<h3 id="demo7-API-setMaxListeners-amp-getMaxListeners-get-amp-set-可绑定回调的上限"><a href="#demo7-API-setMaxListeners-amp-getMaxListeners-get-amp-set-可绑定回调的上限" class="headerlink" title="demo7: API - setMaxListeners &amp; getMaxListeners (get &amp; set 可绑定回调的上限)"></a>demo7: API - setMaxListeners &amp; getMaxListeners (get &amp; set 可绑定回调的上限)</h3><p>默认情况下,每个事件的可绑定回调方法上限是10个, 当绑定第11个回调方法的时候, <strong>程序会抛出 warning</strong>.虽然程序会抛出 warning, 但是当事件被触发的时候, 所有的回调方法都会正常执行.</p>
<p>setMaxListeners 方法是设置 Emitter 可绑定回调方法的上限(<strong>不区分每一个事件的可绑定回调方法上限</strong>, 可增可减).</p>
<p>getMaxListeners 方法则是获取某个 Emitter 的可绑定回调方法上限.</p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventsEmitter = require(&#39;events&#39;);
class MyEmitter extends EventsEmitter {
}
let myEmitter = new MyEmitter();
// 没有下面这一行, 程序会包 warning 哟
// myEmitter.setMaxListeners(20);
const cb1 = () =&gt; console.log(&#39;cb1&#39;);
const cb2 = () =&gt; console.log(&#39;cb2&#39;);
const cb3 = () =&gt; console.log(&#39;cb3&#39;);
const cb4 = () =&gt; console.log(&#39;cb4&#39;);
const cb5 = () =&gt; console.log(&#39;cb5&#39;);
const cb6 = () =&gt; console.log(&#39;cb6&#39;);
const cb7 = () =&gt; console.log(&#39;cb7&#39;);
const cb8 = () =&gt; console.log(&#39;cb8&#39;);
const cb9 = () =&gt; console.log(&#39;cb9&#39;);
const cb10 = () =&gt; console.log(&#39;cb10&#39;);
const cb11 = () =&gt; console.log(&#39;cb11&#39;);
const cb12 = () =&gt; console.log(&#39;cb12&#39;);
const cb13 = () =&gt; console.log(&#39;cb13&#39;);
const cb14 = () =&gt; console.log(&#39;cb14&#39;);
const cb15 = () =&gt; console.log(&#39;cb15&#39;);
myEmitter.on(&#39;me&#39;, cb1);
myEmitter.on(&#39;me&#39;, cb2);
myEmitter.on(&#39;me&#39;, cb3);
myEmitter.on(&#39;me&#39;, cb4);
myEmitter.on(&#39;me&#39;, cb5);
myEmitter.on(&#39;me&#39;, cb6);
myEmitter.on(&#39;me&#39;, cb7);
myEmitter.on(&#39;me&#39;, cb8);
myEmitter.on(&#39;me&#39;, cb9);
myEmitter.on(&#39;me&#39;, cb10);
myEmitter.on(&#39;me&#39;, cb11);
myEmitter.on(&#39;me&#39;, cb12);
myEmitter.on(&#39;me&#39;, cb13);
myEmitter.on(&#39;me&#39;, cb14);
myEmitter.on(&#39;me&#39;, cb15);
myEmitter.emit(&#39;me&#39;);
console.log(&#39;max listeners = &#39; + myEmitter.getMaxListeners());
</code></pre>
<p>输出结果:</p>
<pre><code class="bash">cb1
cb2
cb3
cb4
cb5
cb6
cb7
cb8
cb9
cb10
cb11
cb12
cb13
cb14
cb15
max listeners = 10
(node:14318) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 me listeners added. Use emitter.setMaxListeners() to increase limit
</code></pre>
<h3 id="demo8-API-listenerCount-某个事件回调列表的-length"><a href="#demo8-API-listenerCount-某个事件回调列表的-length" class="headerlink" title="demo8: API - listenerCount(某个事件回调列表的 length)"></a>demo8: API - listenerCount(某个事件回调列表的 length)</h3><p>这个方法返回某个事件所绑定的 回调方法的个数.右有两种写法, 结果是一致的.(这些 api 就是这么简单)</p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventsEmitter = require(&#39;events&#39;);
class MyEmitter extends EventsEmitter {}
let myEmitter = new MyEmitter();
myEmitter.on(&#39;event&#39;, () =&gt; {});
myEmitter.on(&#39;event&#39;, () =&gt; {});
console.log(EventsEmitter.listenerCount(myEmitter, &#39;event&#39;));
console.log(myEmitter.listenerCount(&#39;event&#39;));
</code></pre>
<p>输出结果:</p>
<pre><code class="bash">2
2
</code></pre>
<h3 id="demo9-API-listeners-返回事件回调方法列表"><a href="#demo9-API-listeners-返回事件回调方法列表" class="headerlink" title="demo9: API - listeners(返回事件回调方法列表)"></a>demo9: API - listeners(返回事件回调方法列表)</h3><p>获取某个事件的所有回调方法的列表, 顺序是回调方法的执行顺序.</p>
<p><strong>注: 想看到结果, 要把 listeners() 的返回值打印一下</strong></p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventsEmitter = require(&#39;events&#39;);
class MyEmitter extends EventsEmitter {
}
let myEmitter = new MyEmitter();
const cb1 = () =&gt; console.log(&#39;cb1&#39;);
const cb2 = () =&gt; console.log(&#39;cb2&#39;);
const cb3 = () =&gt; console.log(&#39;cb3&#39;);
const cb4 = () =&gt; console.log(&#39;cb4&#39;);
myEmitter.on(&#39;me&#39;, cb1);
myEmitter.on(&#39;me&#39;, cb2);
myEmitter.on(&#39;me&#39;, cb3);
myEmitter.on(&#39;me&#39;, cb4);
console.log(&#39;listeners list = &#39;);
console.log(myEmitter.listeners(&#39;me&#39;));
</code></pre>
<p>输出结果:</p>
<pre><code class="bash">listeners list = 
[ [Function: cb1],
  [Function: cb2],
  [Function: cb3],
  [Function: cb4]]
</code></pre>
<h3 id="demo10-removeAllListeners-移除全部事件回调"><a href="#demo10-removeAllListeners-移除全部事件回调" class="headerlink" title="demo10: removeAllListeners(移除全部事件回调)"></a>demo10: removeAllListeners(移除全部事件回调)</h3><p>无参数-&gt;移除所有的事件</p>
<p>有参数(eventName)-&gt;移除某一个事件(eventName)的所有回调方法</p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventsEmitter = require(&#39;events&#39;);
class MyEmitter extends EventsEmitter {
}
let myEmitter = new MyEmitter();
const cb1 = () =&gt; console.log(&#39;cb1&#39;);
const cb2 = () =&gt; console.log(&#39;cb2&#39;);
const cb3 = () =&gt; console.log(&#39;cb3&#39;);
myEmitter.on(&#39;me&#39;, cb1);
myEmitter.on(&#39;me&#39;, cb2);
myEmitter.on(&#39;my&#39;, cb3);
console.log(&#39;nothing removed:&#39;)
myEmitter.emit(&#39;me&#39;);
myEmitter.emit(&#39;my&#39;);
console.log(&#39;remove me:&#39;);
myEmitter.removeAllListeners(&#39;me&#39;);
myEmitter.emit(&#39;me&#39;);
myEmitter.emit(&#39;my&#39;);
console.log(&#39;remove all:&#39;);
myEmitter.removeAllListeners();
myEmitter.emit(&#39;me&#39;);
myEmitter.emit(&#39;my&#39;);
</code></pre>
<p>输出结果:</p>
<pre><code class="bash">nothing removed:
cb1
cb2
cb3
remove me:
cb3
remove all:
</code></pre>
<h3 id="demo11-API-removeListener-移除单个事件回调"><a href="#demo11-API-removeListener-移除单个事件回调" class="headerlink" title="demo11: API - removeListener(移除单个事件回调)"></a>demo11: API - removeListener(移除单个事件回调)</h3><p>移除某一个事件的某一个回调方法,入参 [eventName,callback] 一个都不能少, 否则报错</p>
<p>如果某个事件,绑定了3个相同的回调方法 cb3,那么 removeListener 只会移除最后绑定的那个 cb3</p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventsEmitter = require(&#39;events&#39;);
class MyEmitter extends EventsEmitter {
}
let myEmitter = new MyEmitter();
const cb1 = () =&gt; console.log(&#39;cb1&#39;);
const cb2 = () =&gt; console.log(&#39;cb2&#39;);
const cb3 = () =&gt; console.log(&#39;cb3&#39;);
myEmitter.on(&#39;me&#39;, cb1);
myEmitter.on(&#39;me&#39;, cb2);
myEmitter.on(&#39;me&#39;, cb3);
myEmitter.on(&#39;me&#39;, cb2);
myEmitter.on(&#39;me&#39;, cb3);
console.log(&#39;before remove:&#39;);
myEmitter.emit(&#39;me&#39;);
console.log(&#39;after remove cb2:&#39;);
myEmitter.removeListener(&#39;me&#39;,cb2);
myEmitter.emit(&#39;me&#39;);
</code></pre>
<p>输出结果:</p>
<pre><code class="bash">before remove:
cb1
cb2
cb3
cb2
cb3
after remove cb2:
cb1
cb2
cb3
cb3
</code></pre>
<h3 id="demo12-特殊事件-error-事件"><a href="#demo12-特殊事件-error-事件" class="headerlink" title="demo12: 特殊事件 - error 事件"></a>demo12: 特殊事件 - error 事件</h3><p>Emitter 支持一个特殊的事件 -error, 当这个事件被触发的时候, 如果找不到处理的回调方法, 会导致程序崩溃.</p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventsEmitter = require(&#39;events&#39;);
class MyEmitter extends EventsEmitter {}
let myEmitter = new MyEmitter();
myEmitter.emit(&#39;error&#39;, new Error(&#39;whoops!&#39;));
</code></pre>
<p>输出结果:<br><strong>程序非正常退出</strong></p>
<pre><code class="bash">events.js:163
      throw er; // Unhandled &#39;error&#39; event
      ^

Error: whoops!
    at Object.&lt;anonymous&gt; (/Users/zhangtingcen/Documents/my-repo/learning/index.js:60:25)
    at Module._compile (module.js:571:32)
    at Object.Module._extensions..js (module.js:580:10)
    at Module.load (module.js:488:32)
    at tryModuleLoad (module.js:447:12)
    at Function.Module._load (module.js:439:3)
    at Module.runMain (module.js:605:10)
    at run (bootstrap_node.js:423:7)
    at startup (bootstrap_node.js:147:9)
    at bootstrap_node.js:538:3
</code></pre>
<h3 id="demo13-特殊事件-process-uncaughtException"><a href="#demo13-特殊事件-process-uncaughtException" class="headerlink" title="demo13: 特殊事件 - process.uncaughtException"></a>demo13: 特殊事件 - process.uncaughtException</h3><p>因此我们需要一种手段, 来防止(上面)因为没有正确处理 error 事件导致程序直接崩溃.</p>
<p>可以通过给 precess 绑定 uncaughtException 事件, 当 Emitter 类的 error 事件被触发且没有 error 事件的回调方法时, process 的 uncaughtException 事件回调将会被触发.程序也不会崩溃.</p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventsEmitter = require(&#39;events&#39;);
class MyEmitter extends EventsEmitter {}
let myEmitter = new MyEmitter();
process.on(&#39;uncaughtException&#39;, (err) =&gt; {
    console.error(&#39;whoops! there was an error&#39;);
});
myEmitter.emit(&#39;error&#39;, new Error(&#39;whoops!&#39;));
</code></pre>
<p>输出结果:<br><strong>程序正常退出</strong></p>
<pre><code class="bash">whoops! there was an error
</code></pre>
<h3 id="demo14-特殊事件-newListener"><a href="#demo14-特殊事件-newListener" class="headerlink" title="demo14: 特殊事件 - newListener"></a>demo14: 特殊事件 - newListener</h3><p>newListener 事件回调方法, 会默认传入两个参数[eventName(事件名称),listener(回调方法)</p>
<p>在 newListener 事件回调方法中进行绑定事件的操作是一件危险的事情(<strong>分分钟造成死循环</strong>).如果确实要在 newListener 的回调方法中绑定新事件, 用 once 绑定这个危险的回调方法.</p>
<p>下面是一个可以直接执行的 demo</p>
<pre><code class="javascript">const EventsEmitter = require(&#39;events&#39;);
class MyEmitter extends EventsEmitter {}
let myEmitter = new MyEmitter();
let times = 0;
myEmitter.on(&#39;newListener&#39;,(event, listener) =&gt;{
//myEmitter.once(&#39;newListener&#39;,(event, listener) =&gt;{
    console.log(&#39;running times:&#39; + times++);
    console.log(event);
    console.log(listener);
    myEmitter.on(&#39;me&#39;,()=&gt;{})
});
myEmitter.on(&#39;me&#39;,()=&gt;console.log(&#39;start running newListener:&#39;));
myEmitter.emit(&#39;me&#39;);
</code></pre>
<p>输出结果:<br><strong>程序正常退出</strong></p>
<pre><code class="bash">程序陷入死循环,执行了不到一秒就崩溃了
</code></pre>
<h3 id="demo15-特殊事件-removeListener"><a href="#demo15-特殊事件-removeListener" class="headerlink" title="demo15: 特殊事件 - removeListener"></a>demo15: 特殊事件 - removeListener</h3><p>这个特殊事件已经(我学习的时候20171021)变成 <strong>stability:0 - deprecated;</strong>,就是不靠谱的, 移除已经在计划中</p>
<p>就不考虑这个了</p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> emitter </tag>
            
            <tag> nodejs </tag>
            
            <tag> emit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用命令行开启 Webstrom]]></title>
      <url>/2017/10/19/idea-launcher-in-command-line/</url>
      <content type="html"><![CDATA[<h1 id="使用命令行开启-Webstrom"><a href="#使用命令行开启-Webstrom" class="headerlink" title="使用命令行开启 Webstrom"></a>使用命令行开启 Webstrom</h1><p>经常使用 bash 命令辅助工作将会大大提升效率.我仅仅要介绍的是如何在命令行窗口打开 Webstrom.</p>
<p><strong>注:</strong> 仅仅是 macbook 下的经验</p>
<a id="more"></a>
<p>因为从 github clone 下来一个 repo,然后希望在 Webstrom 中打开这个目录.为此我不得不从应用列表找到 Webstrom, 然后在文件系统一层层找到这个目录, 是在是不如直接在 bash 中敲一行命令来的快捷. 我们前端通常称之为更优雅.</p>
<h2 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h2><p>在 Webstrom 中打开当前目录</p>
<pre><code class="bash">$ idea .
</code></pre>
<p>在 Webstrom 中打开某个目录</p>
<pre><code class="bash">$ idea path/to/project
</code></pre>
<p>就是这么快捷</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>Mac 下的 Webstrom 自带创建 bash 命令的功能了.找到菜单路径: </p>
<blockquote>
<p>top bar -&gt; Tools -&gt; Create Command-Line Launcher…</p>
</blockquote>
<p><img src="http://ox32k19xb.bkt.clouddn.com/2017/1508423018501.png" alt=""></p>
<p>点击之后, 还可以自定义这个命令的名称. 可以自定义得简短一些.</p>
<p><img src="http://ox32k19xb.bkt.clouddn.com/2017/1508423278113.png" alt=""></p>
<p>后面就是自行到 shell 里面体验吧, 看, 双击 Tab 已经可以把 webstrom 命令联想出来了</p>
<p><img src="http://ox32k19xb.bkt.clouddn.com/2017/1508423390317.png" alt=""></p>
<h2 id="搜索关键词"><a href="#搜索关键词" class="headerlink" title="搜索关键词"></a>搜索关键词</h2><p>在找到这个菜单前, 我是不知道的, 因此这个方法是我搜索出来的.<br>搜索<code>bash open idea</code>结果踩坑了, 搜索<code>终端 启动 idea</code>终于找到一点点线索, 因此更新关键词为<code>open intellij idea in terminal</code>, 终于找到 <a href="https://www.jetbrains.com/help/idea/2016.1/installing-and-launching.html#command_line_launcher" target="_blank" rel="external">官方文档</a> 了.</p>
<p>然而官方文档竟然没有提到(可能在别处)该如何开启这个功能.好在关键词对了, 答案也就容易找了.</p>
<p>这是最终<a href="https://emmanuelbernard.com/blog/2017/02/27/start-intellij-idea-command-line/" target="_blank" rel="external">参考文档</a></p>
<p><img src="http://ox32k19xb.bkt.clouddn.com/2017/1508423653987.png" alt=""><br>估计不仅仅可以通过目录路径快捷启动 Webstrom, 还有其他功能, 但是我暂时用不到.</p>
]]></content>
      
        <categories>
            
            <category> 日常 </category>
            
            <category> 效率 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Webstrom </tag>
            
            <tag> idea </tag>
            
            <tag> bash </tag>
            
            <tag> mac </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[draft 学习笔记]]></title>
      <url>/2017/10/17/learn-draft/</url>
      <content type="html"><![CDATA[<h1 id="draft-学习笔记"><a href="#draft-学习笔记" class="headerlink" title="draft 学习笔记"></a>draft 学习笔记</h1><p>draft.js 是 facebook 的一个基于 react 的 <em>编辑器</em> 类库.它强于一般的 <em>编辑器</em>/<em>富文本编辑器</em> 插件或组件.</p>
<ul>
<li>draft.js 提供的数据结构&amp;工具方法, 可以非常快速方便得在 draft.js 上层构建一个功能完善的富文本编辑器.</li>
</ul>
<blockquote>
<p>因此 draft.js 不是普通的<em>富文本编辑器</em>, 他是构成<strong>富文本编辑器</strong>的<strong>基础设施</strong></p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>hcm 项目中需要使用到富文本编辑器, 用于编辑一个<em>邮件模板</em>.</p>
<p><em>邮件模板</em>中就会存在<strong>变量</strong>, 通常是用特殊符号包裹起来的一小块, 如我做的项目中的 <code>${variable}</code> ,用 <code>${}</code>包裹起来.</p>
<p>需求: 为了更清晰地看到整个模板中, <em>变量的位置</em>, <code>${}</code> 包裹起来的文本需要高亮显示.</p>
<p>由于之前使用的富文本编辑器 froala-react-wysiwyg 不能完美兼容 react, 并且实现这个需求的过程存在不少坑:</p>
<ul>
<li>性能问题: 每次输入都要正则匹配全部的内容 (这里已经通过动作延迟, 优化了部分性能)</li>
<li>undo/redo栈丢失: 正则匹配完, 并重新设置富文本编辑器内容, 会造成 undo/redo 栈丢失</li>
<li>输入光标位置重置: 每次重置富文本编辑器内容, 都会丢失光标位置, 这一点是硬伤无法解决</li>
</ul>
<p>因此, 从任何角度讲我都要寻找下一个, 更优秀的富文本编辑器.</p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>大致了解 draft.js 并查看了一两个 demo, 我就已经发现, 使用 draft.js 要实现我上面描述的需求简直太简单了.</p>
<p>大致就如这个 <a href="https://github.com/myanbin/myeditor" target="_blank" rel="external">myeditor demo</a> 所示.</p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul>
<li><a href="https://juejin.im/entry/597be4d76fb9a03c32238e80" target="_blank" rel="external">非常优秀的 draft 入门指南</a></li>
<li><a href="https://jpuri.github.io/react-draft-wysiwyg/#/demo" target="_blank" rel="external">一本正经的富文本编辑器, 比较使用, 仍需进一步定制</a></li>
<li><a href="https://github.com/nikgraf/awesome-draft-js#standalone-editors-built-on-draftjs" target="_blank" rel="external">awesome draft, 大部分资料以及优秀 demos 实例集合</a></li>
</ul>
<p>最终, 我说的需求被砍掉了, PM 也不希望我现在就花时间进行优化.<br>所以, 我找到了解决方案, 但是没有时间和心力编写组件或者 demo.期待有时间提出优化吧.</p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react </tag>
            
            <tag> 富文本编辑器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 alfred wrokflow 更舒服地写 blog]]></title>
      <url>/2017/10/16/qiniu-upload/</url>
      <content type="html"><![CDATA[<h1 id="使用-alfred-wrokflow-更舒服地写-blog"><a href="#使用-alfred-wrokflow-更舒服地写-blog" class="headerlink" title="使用 alfred wrokflow 更舒服地写 blog"></a>使用 alfred wrokflow 更舒服地写 blog</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>之前提到过如何更舒服地编写 blog, 已经大大简化了上传图片的步骤.</p>
<p>然而, 我又发现了更加简便的方法.实际使用中的体验达到小高潮.那就是用 <strong>alfred workflow</strong>, 完成粘贴即上传的操作.</p>
<p><strong>注意:</strong> 此方法<strong>仅适用于 macbook</strong>, window 用户应该有同类方法.</p>
<h3 id="实际操作步骤"><a href="#实际操作步骤" class="headerlink" title="实际操作步骤"></a>实际操作步骤</h3><ol>
<li><p>拷贝本地图片;</p>
</li>
<li><p>在文章中粘贴;(粘贴触发将图片上传至七牛云的动作, 并自动生成图片外链)</p>
</li>
</ol>
<p><img src="http://ox32k19xb.bkt.clouddn.com/2017/1508147061635.gif" alt="七牛上传"></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="第一步-安装并了解alfred-workflow"><a href="#第一步-安装并了解alfred-workflow" class="headerlink" title="第一步,安装并了解alfred workflow."></a>第一步,安装并了解<strong>alfred workflow</strong>.</h3><p>在 <a href="http://xclient.info" target="_blank" rel="external">xclient</a> 获取<em>dao版</em> <strong>alfred workflow</strong>.</p>
<p>稍微了解一下就知道使用<strong>alfred workflow</strong>的人们是如何推崇这个工具的.感兴趣可以多多尝试别人分享的<strong>workflow</strong></p>
<h3 id="第二步-找到-alfred-workflow-的资源分享站"><a href="#第二步-找到-alfred-workflow-的资源分享站" class="headerlink" title="第二步,找到 alfred workflow 的资源分享站:"></a>第二步,找到 <strong>alfred workflow</strong> 的资源分享站:</h3><blockquote>
<p>国内介绍网站, 包含一些资源链接: <a href="https://www.waerfa.com/alfred-course-workflow/3" target="_blank" rel="external">https://www.waerfa.com/alfred-course-workflow/3</a></p>
<p>国外 alfred workflow 分享网站: <a href="https://www.alfredforum.com/forum/3-share-your-workflows/?prune_day=100&amp;sort_by=Z-A&amp;sort_key=last_post&amp;topicfilter=all&amp;page=2" target="_blank" rel="external">https://www.alfredforum.com/forum/3-share-your-workflows/?prune_day=100&amp;sort_by=Z-A&amp;sort_key=last_post&amp;topicfilter=all&amp;page=2</a></p>
<p>alfred 官方列举的 workflow 列表: <a href="http://www.alfredworkflow.com/" target="_blank" rel="external">http://www.alfredworkflow.com/</a></p>
</blockquote>
<h3 id="第三步-尝试使用简单的workflow"><a href="#第三步-尝试使用简单的workflow" class="headerlink" title="第三步,尝试使用简单的workflow"></a>第三步,尝试使用简单的<strong>workflow</strong></h3><p>我尝试使用了有道翻译, 然后发现我电脑里面的这个货可以被卸载了</p>
<p><img src="http://ox32k19xb.bkt.clouddn.com/2017/1508146138428.png" alt="有道词典 App"></p>
<p>使用方法: </p>
<ol>
<li><p>github 上下载<a href="https://github.com/wensonsmith/YoudaoTranslate" target="_blank" rel="external">workflow 有道翻译 zip 包</a>,并解压</p>
</li>
<li><p>将文件夹里面的 <em>xxx.workflow</em> 文件拖动到 <strong>alfred workflow</strong> 里面就可以啦.</p>
</li>
<li><p>有兴趣可以按照<a href="https://github.com/wensonsmith/YoudaoTranslate" target="_blank" rel="external">workflow 有道翻译  github</a> 上的 readme 自己尝试配置.</p>
</li>
</ol>
<h3 id="第四步-开始尝试七牛云上传图片的workflow"><a href="#第四步-开始尝试七牛云上传图片的workflow" class="headerlink" title="第四步, 开始尝试七牛云上传图片的workflow"></a>第四步, 开始尝试七牛云上传图片的<em>workflow</em></h3><p><a href="https://github.com/tiann/markdown-img-upload" target="_blank" rel="external">七牛云图床 workflow github</a>使用方法同上.</p>
<p><strong>注意!注意!注意:</strong> 下面有几个关键点</p>
<p>﻿1. 注意阅读 readme, 因为要配置七牛的账号;</p>
<ol>
<li>运行没有反应? 检查电脑的 python 环境!</li>
</ol>
<blockquote>
<p>需要的配置: python 环境, 且安装了 requests 库</p>
<ol>
<li>安装 python 的包管理器 pip : <a href="https://www.zhihu.com/question/50470150?sort=created" target="_blank" rel="external">https://www.zhihu.com/question/50470150?sort=created</a></li>
</ol>
<p><code>$ sudo easy_install pip</code></p>
<ol>
<li>使用 pip 安装 requests 库</li>
</ol>
<p><code>$ sudo pip install requests</code></p>
<p><strong>注意</strong>都要 sudo 权限, 毕竟使用的 mac 系统自带的 python.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 日常 </category>
            
            <category> mac使用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 七牛云 </tag>
            
            <tag> blog </tag>
            
            <tag> alfred workflow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写博客的最佳方式]]></title>
      <url>/2017/10/09/write-blog/</url>
      <content type="html"><![CDATA[<h1 id="写博客的最佳方式"><a href="#写博客的最佳方式" class="headerlink" title="写博客的最佳方式"></a>写博客的最佳方式</h1><p>国庆节把自己的博客开起来了, <a href="https://teeeemoji.github.io" target="_blank" rel="external">teeemoji 的博客</a>, 我的关注点已经从如何美化博客转移到, 如何更舒适地书写文章, 更可靠地保存文章以及如何更方便地发布文章.</p>
<a id="more"></a>
<h1 id="文章源文件的存储"><a href="#文章源文件的存储" class="headerlink" title="文章源文件的存储"></a>文章源文件的存储</h1><p>文章(最终的 md 文件) &amp; 相关笔记, 均保存在 <strong>wiz</strong> 笔记中.使用 wiz 笔记, 一边学习一遍做笔记, 最后在 wiz 中编写文章, 然后发布到 hexo 博客中.</p>
<blockquote>
<p>一篇文章从想法诞生, 到编写过程, 最后发布出去, 这个过程所产生的内容远远不止能看到的这篇文章. 还有很多相关的笔记, 材料, 图片, 都是学习过程的产出和编写文章的副产品.这些相关内容提供文章的内容, 是文章的论据和支撑, 以及提供文章的拓展内容和后续更新方向. 因此一篇文章极其相关笔记应该妥善保管在一起.</p>
</blockquote>
<p>wiz 笔记功能完备, 容量足. 虽然不是最好用的, 但是由于使用习惯问题, 我一直在使用.</p>
<h1 id="文章相关图片的存储"><a href="#文章相关图片的存储" class="headerlink" title="文章相关图片的存储"></a>文章相关图片的存储</h1><p>使用七牛云存储服务实现图床功能.并且使用七牛的 qshell 脚本工具同步图床.</p>
<blockquote>
<p>文章所使用的图片随着文章内容增加占用的空间会非常大, 回非常快速地将我的 github 空间撑爆, 因此必须使用图床工具 or 使用云存储服务实现图床功能.</p>
</blockquote>
<ul>
<li><p>很不幸的是保存在 wiz 笔记中的图片, 外链不可访问</p>
</li>
<li><p>有道云笔记中保存的图片, 可以外链访问呢, 然而作为图床使用仍然是不方便的, 主要在图片的同步, 以及编写文章时插入图片的步骤过于繁琐.</p>
</li>
<li><p>同理使用微博实现图床功能也是不科学的, 步骤太繁琐了</p>
</li>
<li><p>loli.net/sm.ms 匿名图床, 直接上传图片生成外链, 编写文章插入图片的过程变得非常优雅了. 问题在于原始图片数据变得不可管理.</p>
</li>
<li><p>使用七牛云存储免费10G 空间10G 流量, 并且使用 qshell 作为同步工具, 比之 sm.ms 图床更加优雅舒适.</p>
</li>
</ul>
<p>使用步骤简述:</p>
<ol>
<li><p>注册七牛, 并实名, 获得10G 免费空间和流量;</p>
</li>
<li><p>创建对象存储空间(bucket);</p>
</li>
<li><p>下载 qshell 工具, 根据文档尝试使用;</p>
</li>
</ol>
<p><strong>注:</strong> qshell 工具只需要使用到 qupload 命令, qdownload 命令(此命令要钱!?)不需要使用;</p>
<p><strong>注:</strong> 同步图床的命令可以做成 alias: qnu</p>
<h1 id="最终编写文章的步骤"><a href="#最终编写文章的步骤" class="headerlink" title="最终编写文章的步骤"></a>最终编写文章的步骤</h1><p>最终,编写文章,插入图片,到发布的步骤变成如下:</p>
<ol>
<li><p>wiz note 建立文章开始编写;</p>
</li>
<li><p>本地 图库加入图片, 并在 wiz note 中写入图片链接(七牛提供的默认域名/图片在图库的路径+图片名)</p>
</li>
<li><p>hexo new post xxx</p>
</li>
<li><p>修改 post 的 thumbnail 以及格式美化</p>
</li>
<li><p>bash 命令 <code>$ qns</code> 一键同步图床</p>
</li>
<li><p>bash 命令 <code>$ hexo deploy</code> 一键发布博客</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 日常 </category>
            
            <category> 写作 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 七牛云 </tag>
            
            <tag> markdown </tag>
            
            <tag> 写博客 </tag>
            
            <tag> 图床 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[国庆一刷<境界的彼方>]]></title>
      <url>/2017/10/08/anime-jingjiedebifang/</url>
      <content type="html"><![CDATA[<p><img src="/img/post/jingjiedebifang-1.jpg" alt="jingjiedebifang-1"></p>
<p>国庆的某一个深夜 B 站闲逛, 打开境界的彼方 TV 第一集, 发现弹幕都在刷 <strong>‘恭喜你发现神作一枚’</strong>, 加上女主是我在微信上很喜欢的一款萝莉表情, 这番立刻吸引了我的目光.</p>
<a id="more"></a>
<p>(境界的彼方 微信表情 很可爱吧)</p>
<p><img src="/img/post/weixinbiaoqing-jingjiedebifang.jpg" alt="境界的彼方微信表情"></p>
<p>12集长的 TV 版故事节奏把握的非常好, 剧情渐进式, 前期 <em>未来</em> 呆萌惹人怜爱, 让人期望听到 <em>未来</em> 的(悲惨)故事, 在击败 <em>虚空之影</em> 的小高潮后, 马上抛出一整集的福利 - 第六集 - 看得心跳激动并且 <a href="https://bangumi.bilibili.com/anime/3366/play#104935 BiliBili 直链" target="_blank" rel="external">歌舞特典</a> 值得一生收藏哟, 且不是俗套的<a href="https://zhuanlan.zhihu.com/p/29674081 走近科学:动画泳装回的兴奋度研究" target="_blank" rel="external">泳装回</a>哟. 果不其然, 福利过后马上开虐, 一场针对男女主角身世血脉的大阴谋逐渐揭开, 剧情有悬疑有逆转, 不断抛出泪点和惊喜, 直到结局让人不得不给编剧寄刀片的时候, 突如其来地抛出一个<strong>意料之外</strong>的<strong>不合情理</strong>的结局, 竟然让我心满意足的给这部番剧打了个90分.</p>
<h2 id="“前辈-我看起来像个正常人吗-”"><a href="#“前辈-我看起来像个正常人吗-”" class="headerlink" title="“前辈, 我看起来像个正常人吗?”"></a>“前辈, 我看起来像个正常人吗?”</h2><p><em>未来</em> 纠结的是自己收到诅咒的血脉, 受到世界的排挤, 给亲人(小姐姐<em>唯</em>)造成伤害, 因此带有深深自责并且开始怀疑生存的意义, 发出”像我这样的人, 为什么会被生出来”之类的疑问.</p>
<p>当她开始向 <em>秋人</em> 袒露心声时, 她向 <em>秋人</em> 发出这样疑问 - <code>前辈, 我看起来像个正常人吗?</code>, 在我看来已经是在向 <em>秋人</em> 撒娇了.</p>
<p>好在我们的绅(hen)士(tai) <em>秋人</em> 早已喜欢上 <em>未来</em>, 他的回答充满了宠溺 - <code>在我看来, 你只是一个带着眼睛的美少女</code>, <em>未来</em> 听到后也是一脸满(傲)足(娇) - <code>不愉快的说</code>.</p>
<p>么么哒, 你们这波狗粮</p>
<p>因为身世的问题而厌恶自己, 很正常的设定, 编剧这波破的还不错.</p>
<h2 id="“未来-你看我像正常人吗-”"><a href="#“未来-你看我像正常人吗-”" class="headerlink" title="“未来, 你看我像正常人吗?”"></a>“未来, 你看我像正常人吗?”</h2><p>在击败 <em>虚空之影</em> 的时候, <em>秋人</em> 体内的 <em>境界的彼方</em> 暴走, 炸裂输出, 伤害了朋友破坏了森林.</p>
<p>本人醒来以后也是一脸懵逼(但是听说之前也有这种情况, 还把 <em>博臣</em> 的背部击伤), 醒来后和 <em>未来</em> 两人单独吃饭, 低沉落寞地问 <em>未来</em> - <code>我看上去像个普(正)通(常)人吗?</code>.</p>
<p><em>未来</em> 被光速打脸, 比惨大赛 <em>未来</em> 着实比不过 <em>秋人</em> 233.</p>
<p>然而 <em>未来</em> 表情发生微妙变化后, 马上微笑着回答秋人 - <code>在我看来, 你只是一个喜欢眼睛美少女的变态学长</code>.</p>
<p>温馨的狗粮发一波, 你们这对快点出本子吧.</p>
<p>本来以为身世的梗已经被 <em>未来</em> 玩过了, <em>秋人</em> 接着玩一波, 给我造成了难以磨灭的印象, 编剧你实在是高.</p>
<h2 id="针对-秋人-的阴谋"><a href="#针对-秋人-的阴谋" class="headerlink" title="针对 秋人 的阴谋"></a>针对 <em>秋人</em> 的阴谋</h2><p>以下内容涉及严重剧透.</p>
<p>比惨大赛优胜者 - <em>秋人</em>的体质是半妖, 一半是人, 另一半是随时可能造成世界毁灭的妖梦 <em>境界的彼方</em>.尽管 <em>秋人</em> 在人类状态下人畜无害, 知识一个略善良的普通高中生, 但他的存在是整个人类社会的风险, 他的存在也会使某些变态对他产生一些特别的想法(利用他毁灭世界).因此人类阵营会想方设法消灭 <em>秋人</em>.</p>
<p>因此 <em>秋人</em> 和异界师 <em>美月</em> &amp; <em>博臣</em> 产生了超出同学的友谊, 和 <em>名濑</em> 家族保持良好关系只是表象, <em>名濑</em> 家族一直在谋求消灭 <em>境界的彼方</em> 的办法, 只是瞒着 <em>美月</em> 和 <em>博臣</em> 而已.</p>
<p>而 <em>未来</em> 受诅咒的血脉是消灭 <em>境界的彼方</em> 的唯一办法, 她的使命感使得她血脉的力量被 <em>泉姐姐</em> 利用. 直到蛰伏期 <em>泉</em> 刻意压制 <em>秋人</em> 的人性, 引出 <em>境界的彼方</em>, 并且诱导 <em>未来</em> 以牺牲自己的方式换得 <em>秋人</em> 的存活 - 且作为一个普通人活下去.</p>
<p><em>未来</em> 牺牲了自己, 换来一辈子在 <em>境界的彼方</em> 体内跟它战斗, 消磨 <em>境界的彼方</em> 的实力, 使它不足以威胁人类.</p>
<p>然而 <em>藤真弥勒</em> 这个<strong>真~变态</strong>希望借 <em>境界的彼方</em> 之手毁灭世界, 他持续以 <strong>不可知之秘法</strong> 增 <em>境界的彼方</em> 的实力, <em>未来</em> 的战斗苦不堪言.</p>
<p><em>秋人</em> 得知 <em>未来</em> 还活着, 在母亲和众人的帮助下, 进入了 <em>境界的彼方</em> 的体内, 企图救出 <em>未来</em>, 两人相互扶持,艰难战斗, 获得胜利的一刻, <em>未来</em> 破碎了.</p>
<p><em>秋人</em> 体内的 <em>境界的彼方</em> 是 <em>未来</em> 用全身的血液换过来的, 换来 <em>未来</em> 与 <em>境界的彼方</em> 的共同生存, 然而 <em>秋人</em> 再次将 <em>境界的彼方</em> 夺回体内, <em>未来</em> 的存在也就失去了支撑. (mmp 为什么不是换来 <em>秋人 境界的彼方 未来</em> 三人的共生).崩溃的 <em>秋人</em> 开始了他浑浑噩噩的一生 (emoji).</p>
<p><em>未来</em> 你活该, 你什么都不懂, 现在什么都没有改变, 然而你却挂了.</p>
<p>P.S. 我要是 <em>未来</em> 知道真相后真想砍死 <em>泉</em>.</p>
<h2 id="他们两个人的心意"><a href="#他们两个人的心意" class="headerlink" title="他们两个人的心意"></a>他们两个人的心意</h2><p>也许 <em>秋人</em> 只有 0.1% 的风险会毁灭世界, 人类也不可能与他和平共处. 因此 <em>未来</em> 必然要想出一个消灭 <em>境界的彼方</em> 的办法, 她笨拙得希望以自己的牺牲换来 <em>秋人</em> 的幸福.</p>
<p><em>秋人</em> 喜欢 <em>未来</em>, 希望保护 <em>未来</em>, 拯救 <em>未来</em>.得知这个傻姑娘舍身救己, 又气愤又感动, 并且的值 <em>未来</em> 的下落毫不犹豫就过去救她.<em>秋人</em> 在失去 <em>未来</em> 的时候, 则是过着浑浑噩噩的日子.在未来篇 <em>秋人</em> 是这样向 <em>未来</em> 表白的 - <code>我活着不是因为我的不是之身, 而是因为有你</code>.</p>
<p>他们两人相互依靠, 互为生存意义.</p>
<h2 id="一些记忆深刻的剧情"><a href="#一些记忆深刻的剧情" class="headerlink" title="一些记忆深刻的剧情"></a>一些记忆深刻的剧情</h2><p>想你的腋, 一腋知秋, 腋来香: 233 剧中反复出现的梗, 配合弹幕使用笑料加倍</p>
<p>未来篇 <em>泉</em> 为什么会自愿植入妖梦: 估计是看到弟弟 <em>博臣</em> 被 妖梦化的 <em>秋人</em> 打伤, 渴望获得力量保护亲人吧. 因此 <em>泉</em> 才会迫切渴望消灭 <em>境界的彼方</em>.</p>
<p><em>秋人</em> 你爹呢: 这部番的第二个名字一定叫 <code>未闻爹名</code> 233.无论是 TV , 过去篇, 未来篇都没有出现过秋人父亲的消息, 秋人他妈妈也是个细思极恐的角色.</p>
<p><em>秋人</em> 与照相馆: 他们对于可爱的 <em>未来</em> 的写真的 PY 交易, 慢慢的笑料.</p>
<p><em>秋人</em> 的记事本: 秋人加堆满的写真本并且认真写上评论及打分, 满满的笑料, 包括 <em>未来</em> 在写真馆的打工, 可想而知 <em>秋人</em> 真的是一个喜欢 <em>未来</em> 到无可救药的 绅(hen)士(tai).</p>
<p>没头脑和不高兴: <em>未来</em> 的口头禅 <strong>不高兴的说</strong>, 有些时候显得僵硬的蹭的累桥段, 有些时候真的很棒.</p>
<p>妹控 <em>博臣</em>: 妹控的笑料很多, 最最最细节的一个笑料自己去找图 - <em>秋人</em> 梦里看到 <em>美月</em> 太阳镜+泳装的时候, <em>博臣</em> 在旁边用潜望镜偷看. 细节就是 - <em>博臣</em> 偷看到脸都晒黑了, 就剩看潜望镜的眼眶还是白的 233,666.</p>
<h2 id="最后问一句"><a href="#最后问一句" class="headerlink" title="最后问一句"></a>最后问一句</h2><p>半年不到, 你会深爱一个人到, 愿意付出生命也希望 TA 获得幸福, 的程度吗?</p>
<hr>
<h2 id="其他的剧评"><a href="#其他的剧评" class="headerlink" title="其他的剧评"></a>其他的剧评</h2><p><a href="https://www.zhihu.com/question/22204928" target="_blank" rel="external">知乎: 如何评价&lt;境界的彼方&gt;这部动画?</a></p>
<p><a href="https://zhihu.com/question/22204928/answer/26950922" target="_blank" rel="external">其中的一个长评</a></p>
]]></content>
      
        <categories>
            
            <category> 日常 </category>
            
            <category> anime </category>
            
        </categories>
        
        
        <tags>
            
            <tag> anime </tag>
            
            <tag> 境界的彼方 </tag>
            
            <tag> 栗山未来 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[node package - minimist & 命令行参数解析规则学习笔记]]></title>
      <url>/2017/10/08/learn-minimist/</url>
      <content type="html"><![CDATA[<h1 id="node-package-minimist-amp-命令行参数解析规则学习笔记"><a href="#node-package-minimist-amp-命令行参数解析规则学习笔记" class="headerlink" title="node package - minimist &amp; 命令行参数解析规则学习笔记"></a>node package - minimist &amp; 命令行参数解析规则学习笔记</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我希望使用 node 做一个 <strong>CLI (Command line interface)</strong> 工具, 因此必须解析命令行参数数组 <em>process.argv</em>.</p>
<a id="more"></a>
<p><strong>第一种方案是,</strong> 对参数数组 process.argv 直接处理, 编写 swtich or if 语句块, 根据不同的参数做不同的处理.</p>
<p><strong>第二种方案是,</strong> 写一个命令行参数解析 <strong>helper</strong>, 将 <em>process.argv</em> 解析成一个<strong>对象</strong>, 再进行下一步处理.</p>
<p><strong>第一种方案,</strong> 在命令行参数足够复杂的时候, 会在工具读取参数的过程逻辑复杂化, 着实不可取的.</p>
<p><strong>第二种方案,</strong> 则是一种通用的解决方案, 一次编写, 所有的命令行工具都可以使用.</p>
<p>在使用第二种方案的时候, 我们的目的是将 process.argv 数组解析成一个对象,包含一个个键值对 key =&gt; value, 那么 <em>process.argv</em> 中哪些项是键, 哪些是 value, 就需要制订一种规则 - <strong>命令行的参数输入规则</strong>.通常使用约定成熟的 unix command line 规则.</p>
<p>因此我找到了现成的 nodejs 环境下的<strong>命令行参数解析 engine</strong> - <a href="https://www.npmjs.com/package/minimist" title="npmjs - minimist" target="_blank" rel="external"><code>minimist</code></a></p>
<h2 id="node-package-minimist"><a href="#node-package-minimist" class="headerlink" title="node package - minimist"></a>node package - minimist</h2><p>minimist 是 nodejs 下的一个命令行参数解析引擎, 功能就是将 process.argv 中的参数解析成一个对象.</p>
<blockquote>
<p>查阅<a href="https://www.npmjs.com/package/minimist" title="npmjs - minimist" target="_blank" rel="external">minimist 官方文档</a>更快获得支持.</p>
</blockquote>
<h3 id="基本用法如下"><a href="#基本用法如下" class="headerlink" title="基本用法如下:"></a>基本用法如下:</h3><pre><code class="javascript">#!/usr/bin/env node
var argv = require(&#39;minimist&#39;)(process.argv.slice(2));
console.dir(argv);
</code></pre>
<p>为什么输入参数是 <strong>process.argv.slice(2)</strong>?<br>我们在 shell 中输入的命令行如下</p>
<pre><code class="bash">$ node cmd.js xxx sss xxx sss xxx
</code></pre>
<p><strong>process.argv[0]</strong> 是 <strong>shell 类型</strong>, 即 <strong>node</strong>. <strong>process.argv[1]</strong> 则是工具本身的路径.</p>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><pre><code class="javascript">#!/usr/bin/env node
var argv = require(&#39;minimist&#39;)(process.argv.slice(2), opts={});
console.dir(argv);
</code></pre>
<p>opts 的更多介绍, 就在文档中(也可以查看源码,毕竟就一个 index.js 文件), 最主要使用的 opts.default 属性, 定义默认的参数.</p>
<h2 id="命令行参数规则总结"><a href="#命令行参数规则总结" class="headerlink" title="命令行参数规则总结"></a>命令行参数规则总结</h2><p>以下命令行参数是我在 <em>minimist</em> 的使用过程中总结出来的. 逐个解析 <em>process.argv</em> 的每一个 item</p>
<ol>
<li>item 不是 key, 将会被放入key 为 ‘_’ 的数组中<pre><code class="javascript">// $ node cmd.js arg1 arg2 arg3 arg4 arg5
// &gt; { _: [ &#39;arg1&#39;, &#39;arg2&#39;, &#39;arg3&#39;, &#39;arg4&#39;, &#39;arg5&#39; ] }
</code></pre>
</li>
<li>item 是 key(_+单个字符), item 会作为 key, nextItem(非 key) 会被作为 value, 扔进结果集<pre><code class="javascript">// $ node cmd.js -u root -p password password1 password2
// &gt; { _: [ &#39;password1&#39;, &#39;password2&#39; ], u: &#39;root&#39;, p: &#39;password&#39; }
</code></pre>
<blockquote>
<p>注: 单个字符包含字母, 数字, 其他特殊字符在不造成 shell 误解的情况也可以使用.但<code>(</code> , <code>)</code> , <code>&amp;</code> , <code>|</code> 亲测不行</p>
</blockquote>
</li>
</ol>
<p>如果 nextItem(是 key), 那么 item 会被作为 boolean 类型且值为 true 扔进结果集</p>
<pre><code class="javascript">// $ node cmd.js -a -b testing
// &gt; { _: [], a: true, b: &#39;testing&#39; }
</code></pre>
<p>还有一种特殊情况, _+多个字符会怎么样?</p>
<pre><code class="javascript">// $ node cmd.js -u root -p password -abcd
// &gt; { _: [],
//          u: &#39;root&#39;,
//          p: &#39;password&#39;,
//          a: true,
//          b: true,
//          c: true,
//          d: true 
//      }
</code></pre>
<p>3.当 item 以 ‘–’(双横杠)开头的时候, item 将会被解析成一个对像(注意两种 boolean)</p>
<pre><code class="javascript">// $ node cmd.js --ssl --no-cookie --user=root --password=asdf
// &gt; { _: [], ssl: true, cookie: false, user: &#39;root&#39;, password: &#39;asdf&#39; }
</code></pre>
<h2 id="minimist-代码解读"><a href="#minimist-代码解读" class="headerlink" title="minimist - 代码解读"></a>minimist - 代码解读</h2><p>就一个 index.js 文件, 语法也不难懂.最主要的逻辑在于一个 for 循环.对于 opts 的处理逻辑也不复杂.重点在于, 看代码前先看文档, 知道 opts 的作用在读代码就轻松多了, 毕竟, 这代码也没啥注释.</p>
<pre><code class="javascript">for (var i = 0; i &lt; args.length; i++) {
    var arg = args[i];

    if (/^--.+=/.test(arg)) {
        ...
    }
    else if (/^--no-.+/.test(arg)) {
        ...
    }
    else if (/^--.+/.test(arg)) {
        ...
    }
    else if (/^-[^-]+/.test(arg)) {
        ...
    }
    else {
       ...
    }
}
</code></pre>
<h2 id="同类型工具"><a href="#同类型工具" class="headerlink" title="同类型工具"></a>同类型工具</h2><p>同是 nodejs 下的命令行参数解析引擎<a href="https://www.npmjs.com/package/optimist" title="npmjs - optimist" target="_blank" rel="external">optimist</a> ,读读 readme.md 吧, optimist的作者自己跑去用 minimist 了, 弃坑了…</p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
            <category> node </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> node </tag>
            
            <tag> minimist </tag>
            
            <tag> 命令行参数解析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PSP 篇]]></title>
      <url>/2017/10/08/my-psp-20171007/</url>
      <content type="html"><![CDATA[<p><img src="/img/post/psp-running.png" alt="psp 现在的样子" title="PSP 通电"></p>
<p>高中的时候我把玩着同学 PSP 的时候, 内心是非常渴望自己也能有一台的. 那时候几个宿舍的同学, 拿着阿达和 OB 的两台 PSP, 轮流玩高达, 玩孙悟空之类的对战格斗游戏, 根本没有什么技术可言, 就是一顿乱按, 也爽的不行.</p>
<a id="more"></a>
<p>后来是大二下学期, 我在宿舍沉迷 PC 版的 galgame - Clannad, 被古河渚骗去不少眼泪, 因此和 galgame 结下不解之缘. </p>
<p>所以大二暑假时期, 我这个厚脸皮的大学生跟父亲提到想要一个游戏机, 而父亲竟然非常爽快地答应了. 尽管是现在仍回忆不起当时的情形, 父亲为什么会答应我这不成熟的请求.</p>
<p>当然, 大二大三就沉迷游戏不可自拔, 当时还在恋爱, 也在日复一日地玩’恋爱’游戏.</p>
<p>给 PSP 盖上贴纸的契机, 是我看了一部动漫 - &lt;命运石之门 - steins;gate&gt;, 一切都是石头门的选择.看完动漫已然沉迷, 正好找到了 PSP 汉化版游戏, 一顿玩之后决定贴个膜吧. </p>
<p>之后更是把<steins;gate>推荐给女朋友玩, 那个旺仔就是她贴上去的, 虽然我和她已经分手多年, 但这个旺仔至今还好好地.</steins;gate></p>
<p><img src="/img/post/psp-front.png" alt="psp 正面照" title="PSP 正面"></p>
<p>背面助手的脸已经掉了, 好惨.</p>
<p><img src="/img/post/psp-back.png" alt="psp 背面照" title="PSP 背面"></p>
<p>后来又把 PSP 借给月冥玩, 有点强迫她她玩<steins;gate>, 试试想像喜欢一个作品的人会有多么疯狂.PSP 在她那儿呆了一年才被我收回来.最后, 大学毕业后, PSP 一直在吃灰.那时候我迷上了英雄联盟.</steins;gate></p>
<p>PSP 已经老了, 屏幕画面显得粗糙, 也不会再有新游戏登录 PSP 平台了, 我也会在 mac 上的 psp 模拟器上玩高清的 PSP 游戏. 我会一直保留着它, 这个陪我度过很长时间, 承载了很多快乐回忆, 悲伤时给我安慰, 的老机器.去年孤身来到北京生活的时候, 我带着我的 PSP, 也许以后我还会再次充满电, 一边回忆从前一边玩着老游戏.</p>
<p>以后买个陈列架, 把这 PSP 封印进去吧.</p>
]]></content>
      
        <categories>
            
            <category> 日常 </category>
            
            <category> 物件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PSP </tag>
            
            <tag> galgame </tag>
            
            <tag> 命运石之门 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[博客美化进程]]></title>
      <url>/2017/10/07/blog-beauty-20171007/</url>
      <content type="html"><![CDATA[<h1 id="Teeeemoji-的博客美化进程"><a href="#Teeeemoji-的博客美化进程" class="headerlink" title="Teeeemoji 的博客美化进程"></a>Teeeemoji 的博客美化进程</h1><p>要美化的地方右好多好多, 要添加的新功能也有好多</p>
<h2 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h2><ul>
<li>LOGO</li>
<li>favicon 更换</li>
</ul>
<a id="more"></a>
<h2 id="clear-事项"><a href="#clear-事项" class="headerlink" title="clear 事项"></a>clear 事项</h2><ul>
<li>音乐列表功能, 尝试能不能使用网易云音乐的服务<br>参考 <a href="http://weqeo.com/2016/10/11/Hexo%E4%B8%AD%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%9A%84%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">weqeo 的博文</a><br>感觉加入网易云音乐的功能非常非常的鸡肋<br>切换文章, 啪地音乐就断了…<br>使用非常简单, 网易云音乐可以直接生成 iframe 的播放器, 插入页面的 layout 中就可以了<br>我最终决定不实用这个功能</li>
<li>全站 https 加密<br>这个看了看, 我目前没有必要用, 申请友链的话, 我就用 teeeemoji.github.io 就可以了,哈哈</li>
<li>使用 topPost<br>参照文档<a href="https://material.viosey.com/docs/#/config/services?id=toppost" target="_blank" rel="external">Material topPost</a><br>安装好包, 然后在某个文章的 front-matter 中配置 top: true, 搞定, 置顶某一篇文章</li>
<li>Rss 订阅服务<br>查半天不知道 rss 有什么用,都是再说怎么用 rss 或者说 rss 的原理的<br>算了, 参照 <a href="https://material.viosey.com/docs/#/config/services?id=rss" target="_blank" rel="external">Material Rss</a>弄一弄, 以后有用到的时候再说吧<br>配置使用 hexo-generator-feed 的 readme.md 中的默认配置</li>
<li>加入搜索系统<br>使用 Google 的搜索服务好像不顶用啊, 站内搜索毛都没有<br>使用本地搜索体验杠杠的,即时搜索+suggest 既视感, 但是由于要加载 search.xml, 这个文件看起来并不小, 所以网站速度可以想象<br>参考 <a href="https://material.viosey.com/docs/#/config/services?id=%e6%9c%ac%e5%9c%b0%e6%90%9c%e7%b4%a2" target="_blank" rel="external">Material 搜索系统</a><br>还有一种搜索系统, <a href="http://swiftype.com/" target="_blank" rel="external">Swiftype</a>略嫌麻烦, 所以不再尝试了</li>
<li>数据统计与分析<br>参考文档 <a href="https://material.viosey.com/docs/#/config/services?id=%e6%95%b0%e6%8d%ae%e7%bb%9f%e8%ae%a1%e4%b8%8e%e5%88%86%e6%9e%90" target="_blank" rel="external">Material 数据统计与分析</a><br>加入 <a href="tongji.baidu.com">百度统计</a> 用邮箱注册一个百度统计账号, 贼简单<br>加入 <a href="http://www.umeng.com/" target="_blank" rel="external">cnzz(友盟)</a><br>同样用邮箱注册一个友盟账号, 加入非常简单<br>加入 <a href="analytics.google.com">google analytics</a><br>同样用163邮箱注册一个google账号, 加入非常简单</li>
<li>评论第三方服务<br>使用 <a href="https://livere.com/" target="_blank" rel="external">LiveRe(来必力)</a><br>使用方法参考<a href="https://material.viosey.com/docs/#/config/services" target="_blank" rel="external">Material 第三方服务</a></li>
<li>文章添加缩略图<br>这个缩略图, 指的是文章列表显示的每一篇文章头部的图片</li>
</ul>
<ol>
<li>默认的随机缩略图<br>放置在 img/gallaxy/ 目录下, 从 <a href="">NASA</a> 下载的一堆太空美图, 图片质量没得说, 照顾网站速度与主机流量, 都是用的是中等画质的图片</li>
<li>文章定制的缩略图<br>文章的 front-matter 中设置字段 thumbnail<br>P.S. <a href="https://hexo.io" target="_blank" rel="external">Hexo 官方文档</a>中对 front-matter 的介绍中没看到, 全靠自己灵光一闪实验出来的<br>个人介绍: 只是一个人,因为很想你<br>一句话: 日事清,不贰过 </li>
</ol>
<ul>
<li>更换背景图<br>直接使用我电脑桌面图片了, 风格我自己表示很满意</li>
<li>添加菜单<br>左侧菜单列表内容, 参考 <a href="https://blog.viosey.com/" target="_blank" rel="external">Viosey’s Blog</a><br>home,归档,分类,gallery,about,friends links,tags,timeline,Articles</li>
<li>添加 pages<br>上面说的每一个菜单, 其实都对应一个页面, 用下面这种方式先添加页面, 然后按照文档进行配置(有几个页面连配置都不需要)<pre><code>$ hexo new page &#39;xxx&#39;
</code></pre>添加方式参考 <a href="https://material.viosey.com/docs/#/pages" target="_blank" rel="external">Material 独立页面</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 日常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> testing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Teeeemoji's First Blog Post]]></title>
      <url>/2017/10/06/first-post-20171006/</url>
      <content type="html"><![CDATA[<p>非常高兴能够创建自己的博客, 我希望能经常发表文章, 给其他程序员带来帮助.也能将自己的知识沉淀下来.</p>
<p>2017-10-06 创建自 Hexo.</p>
<a id="more"></a>
<p>这只是一篇实验性的文章.</p>
<blockquote>
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p>
</blockquote>
<p>##为什么 markdown 不生效?</p>
<h3 id="因为-hexo-识别-markdown-标题-需要-后面跟一个空格"><a href="#因为-hexo-识别-markdown-标题-需要-后面跟一个空格" class="headerlink" title="因为 hexo 识别 markdown 标题, 需要#后面跟一个空格"></a>因为 hexo 识别 markdown 标题, 需要#后面跟一个空格</h3><p><strong>双*号括起来的</strong><br><em>单\</em>号括起来的*<br><strong>双_括起来的</strong><br><em>单\</em>括起来的_<br><code>单个反引号括起来</code></p>
<p><code>javascript _.compat http://teeeemoji.xyz teeeemoji.xyz
alert(&quot;hello world&quot;);</code><br><a href="http://teeeemoji.xyz" title="teeemoji&#39;s website">这里是一个超链接</a></p>
<p>下面哪个是图片超链接<br><a href="http://teeeemoji.xyz" title="teeemoji&#39;s website"><img src="https://s.gravatar.com/avatar/7c5a002366e136a8413c7845f98398ad?size=100&amp;default=retro" alt="touxiangtupian" title="touxiang"></a></p>
<p>下面哪个是网址超链接</p>
<teeeemoji.github.io>



</teeeemoji.github.io>]]></content>
      
        <categories>
            
            <category> 日常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 搭建博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> testing </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
